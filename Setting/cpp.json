{
    "cpt": {
        "prefix": "shadow088",
        "body": [
            "#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector,fast-math\")",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "namespace std{",
            "using namespace __gnu_pbds;",
            "template<typename T>",
            "using ordered_set   =   tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
            "};",
            "",
            "#ifndef ONLINE_JUDGE",
            "#define debug(x)              \\",
            "    cerr << #x << \" = [ \";    \\",
            "    for (const auto &val : x) \\",
            "        cerr << val << \" \";   \\",
            "    cerr << \"]\\n\"; // works fine for now",
            "#define error(args...) { \\",
            "    string _s = #args; \\",
            "    replace(_s.begin(), _s.end(), ',', ' '); \\",
            "    stringstream _ss(_s); \\",
            "    istream_iterator<string> _it(_ss); \\",
            "    _err(_it, args); \\",
            "}",
            "void _err(istream_iterator<string> it) { cerr << \"\\n\"; }",
            "template <typename T, typename... Args>",
            "void _err(istream_iterator<string> it, T a, Args... args) {",
            "    cerr << *it << \" = \" << a << \" | \";",
            "    _err(++it, args...);",
            "}",
            "#else",
            "#define debug(...)",
            "#define error(...)",
            "#endif",
            "",
            "// Type definitions",
            "typedef long long ll;",
            "typedef long long lli;",
            "typedef long double lld;",
            "using ull = uint64_t;",
            "typedef pair<int, int> pii;",
            "typedef pair<lli, lli> pll;",
            "typedef vector<int> vi;",
            "typedef vector<vi> vvi;",
            "typedef vector<lli> vll;",
            "typedef vector<vll> vvl;",
            "typedef vector<bool> vb;",
            "typedef vector<string> vs;",
            "typedef vector<char> vc;",
            "typedef vector<vc> vvc;",
            "",
            "// Constants",
            "const lli mod = 1e9 + 7; //998244353; ",
            "const lli mod1 = 1e9 + 7; ",
            "const lli mod2 = 998244353; ",
            "const lli MAXN = 1e6;",
            "const double eps = 1e-10;",
            "const lli LINF = 1001002003004005006ll;",
            "const int INF = 1001001001;",
            "const int MX = 200005;",
            "constexpr int dx[] = {0, 0, 1, -1};",
            "constexpr int dy[] = {1, -1, 0, 0};",
            "const string ny[] = {\"NO\", \"YES\"};",
            "const string nys[] = {\"No\", \"Yes\"};",
            "",
            "// Macros",
            "#define all(x) (x).begin(), (x).end()",
            "#define rall(x) (x).rbegin(), (x).rend()",
            "#define rev(x) reverse(all(x))",
            "#define srt(x) sort(all(x))",
            "#define maxx (lli) fmax",
            "#define minn (lli) fmin",
            "#define pb push_back",
            "#define F first",
            "#define S second",
            "#define pi acos(-1.0)   // 2*asinl(1.0);",
            "#define sq(x) ((x) * (x))",
            "#define issq(x) (((lli)(sqrt((x)))) * ((lli)(sqrt((x)))) == (x))",
            "#define lg(r, n) (lli)(log2l(n) / log2l(r))",
            "#define setpre(n) fixed << setprecision(n)",
            "#define UNIQUE(a) (a).erase(unique(all(a)), (a).end())",
            "#define take(p, n, T) \\",
            "    vector<T> p(n);   \\",
            "    for (auto &i : p) \\",
            "        cin >> i;",
            "#define input(x)      \\",
            "    for (auto &i : x) \\",
            "    cin >> i",
            "#define print(x)              \\",
            "    for (const auto &val : x) \\",
            "        cout << val << \" \";   \\",
            "    cout<<endl;",
            "// Loop macros",
            "#define loop(i, n) for (int i = 0; i < (n); ++i)",
            "#define rloop(i, n) for (int i = (n) - 1; i >= 0; --i)",
            "#define sloop(i, s, t) for (int i = s; i < t; ++i)",
            "",
            "// Utility macros",
            "#define arrsum(arr) std::accumulate(arr.begin(), arr.end(), 0LL)",
            "#define maxs(x, y) (x = max(x, y))",
            "#define mins(x, y) (x = min(x, y))",
            "template<class T> bool chmax(T &a, const T &b) { if(a<b){a=b;return 1;}return 0;}",
            "template<class T> bool chmin(T &a, const T &b) { if(a>b){a=b;return 1;}return 0;}",
            "#define limit(x, l, r) max(l, min(x, r))",
            "#define lims(x, l, r) (x = max(l, min(x, r)))",
            "#define isin(x, l, r) ((l) <= (x) && (x) <= (r))",
            "#define pcnt __builtin_popcountll",
            "#define snuke srand((unsigned)clock() + (unsigned)time(NULL))",
            "#define show_var(x) cout << #x << \" = \" << x << endl",
            "#define PQ(T) priority_queue<T, vector<T>, greater<T>>",
            "#define bn(x) ((1 << (x)) - 1)",
            "#define dup(x, y) (((x) + (y) - 1) / (y))",
            "#define drnd(x, y) (((x) + (y) / 2) / (y))",
            "#define nl cout<<endl;",
            "#define YES cout<<\"YES\"<<endl;",
            "#define NO cout<<\"NO\"<<endl;",
            "#define Yes cout<<\"Yes\"<<endl;",
            "#define No cout<<\"No\"<<endl;",
            "#define tc    \\",
            "    int t;    \\",
            "    cin >> t; \\",
            "    for (int ii = 1; ii <= t; ++ii)",
            "#define tc0    \\",
            "    int t = 1; \\",
            "    for (int ii = 1; ii <= t; ++ii)",
            "#define gp \" \"",
            "#define case(ii) cout << \"Case \" << ii << \": \"",
            "#define freopen                       \\",
            "    freopen(\"input.txt\", \"r\", stdin); \\",
            "    freopen(\"output.txt\", \"w\", stdout);",
            "// Graph input macro",
            "#define readgraph(arr, edges)         \\",
            "    for (int i = 0; i < (edges); i++) \\",
            "    {                                 \\",
            "        int a, b;                     \\",
            "        cin >> a >> b;                \\",
            "        arr[a].pb(b);                 \\",
            "        arr[b].pb(a);                 \\",
            "    }",
            "#define by(x) [](const auto &a, const auto &b) { return a.x < b.x; }//depends" 
            ,
            "#define tolower_str(s) transform(all(s), s.begin(), ::tolower)",
            "#define toupper_str(s) transform(all(s), s.begin(), ::toupper)",
            "#define cng_str(s) transform(all(s), s.begin(), [](char c) { return c ^ ' '; })",
            "#define clr(arr, val) memset(arr, val, sizeof(arr))",
            "",
            "// Utility functions",
            "inline lli gcd(lli a, lli b) { return b == 0 ? a : gcd(b, a % b); }",
            "#define lcm(a, b) (1LL*(a) * (b)) / gcd(a, b)",
            "",
            "inline lli madd(lli a, lli b, lli m = mod) { return ((a %m)  + (b % m)) % m; }",
            "inline lli msub(lli a, lli b, lli m = mod) { return (((a % m) - (b % m)) % m + m) % m; }",
            "inline lli mmul(lli a, lli b, lli m = mod) { return ((a % m) * (b % m)) % m; }",
            "inline lli mpow(lli base, lli exp, lli m = mod) {",
            "    lli res = 1LL;",
            "    while (exp > 0) {",
            "        if (exp & 1) res = mmul(res, base, m);",
            "        base = mmul(base, base, m);",
            "        exp >>= 1LL;",
            "    }",
            "    return res;",
            "}",
            "inline lli minv(lli a, lli m = mod) { return mpow(a, m - 2, m); }",
            "",
            "// *****************************************************",
            "// ------------------- CODE STARTS HERE ----------------",
            "// *****************************************************",
            "",
            "int main() {",
            "    ios::sync_with_stdio(0);",
            "    cin.tie(0);",
            "    cout.tie(0);",
            "",
            "    tc0 {",
            "        ",
            "    }",
            "}"
        ],
        "description": "Complete CP Template"
    },
    "Divisors Array Initialization": {
        "prefix": "divisors_array",
        "body": [
            "ll N = 100002;",
            "vvl div(N + 1);//for DP ",
            "for (int i = 1; i < N; i++) {",
            "    for (int j = i; j < N; j += i) {",
            "        div[j].push_back(i);",
            "    }",
            "}"
        ],
        "description": "Initialize divisors for numbers from 1 to N"
    },
    "BIT (Fenwick Tree)": {
        "prefix": "bit",
        "body": [
            "struct BIT {",
            "    vector<ll> bit;  // The underlying array (1-based indexing)",
            "    ll n;            // Size of the tree (1..n)",
            "",
            "    // Constructor - creates tree of size n (1-based)",
            "    BIT(ll size) : n(size) {",
            "        bit.assign(n + 1, 0);  // Index 0 is unused",
            "    }",
            "",
            "    // Returns sum from index 1 to i (1-based)",
            "    //i & (-i) right most set bit",
            "    ]//i-(i & (-i)) removing right most set bit",
            "",
            "    ll sum(ll i) {",
            "        ll res = 0;",
            "        for (; i > 0; i -= i & -i)",
            "            res += bit[i];",
            "        return res;",
            "    }",
            "",
            "    // Returns sum from index l to r (1-based)",
            "    ll rangeSum(ll l, ll r) {",
            "        return sum(r) - sum(l - 1);",
            "    }",
            "",
            "    // Adds delta to element at index i (1-based)",
            "    void update(ll i, ll delta) {",
            "        for (; i <= n; i += i & -i)",
            "            bit[i] += delta;",
            "    }",
            "};",
            "",
            "// Usage examples:",
            "// BIT ft(n); // Initialize",
            "// ft.update(i, delta); // Point update",
            "// ft.sum(i); // Prefix sum",
            "// ft.rangeSum(l, r); // Range sum"
        ],
        "description": "1-based Fenwick Tree (Binary Indexed Tree) implementation"
    },
    "C++ Permutation Loop": {
        "prefix": "permutation_generate",
        "body": [
            "vll p;",
            "do",
            "{",
            "    vll q;",
            "    lli sum = 0;",
            "    loop(i, n)",
            "    {",
            "        $1",
            "    }",
            "   ",
            "    if(is_permutation(all(q), p.begin())){",
            "        debug(p);",
            "        debug(q);",
            "    };",
            "} while (next_permutation(all(p)));",
            "$0"
        ],
        "description": "C++ permutation loop with debug check"
    },
    "interactive": {
        "prefix": "ask_interactive",
        "body": [
            "void Interact(){",
            "    #undef endl",
            "    std::cout << std::endl;",
            "    std::cout.flush();",
            "    #define endl '\\n'",
            "}",
            "",
            "ll ask(ll l, ll r){",
            "    std::cout << \"? \" << l << gp << r;",
            "    Interact();",
            "    ll res; std::cin>>res;",
            "    return res;",
            "}",
            "",
            "void Report(std::vector<ll> &perm){",
            "    std::cout << \"! \";",
            "    for(auto &pr : perm) std::cout << pr << gp;",
            "    Interact();",
            "}"
        ],
        "description": "Interactive code block for competitive programming with gp as separator"
    },
    "sieve1": {
        "prefix": "prime_sieve",
        "body": [
            "vector<bool> primes(MAXN, 1);",
            "primes[0] = primes[1] = 0;",
            "for (int i = 2; i * i <= MAXN; i++) {",
            "    if (primes[i] == 1) {",
            "        for (int j = i * i; j <= MAXN; j += i) {",
            "            primes[j] = 0;",
            "        }",
            "    }",
            "}",
            "for (int i = 0; i <= MAXN; i++) if (primes[i]) p.pb(i);"
        ],
        "description": "Sieve of Eratosthenes to find primes up to MAXN"
    },
    "sieve2": {
        "prefix": "sieve_fact",
        "body": [
            "vector<lli> primes(MAXN + 1, -1);",
            "void sieve() {",
            "    for (lli i = 2; i <= MAXN; ++i) {",
            "        if (primes[i] == -1) {",
            "            for (lli j = i; j <= MAXN; j += i) {",
            "                if (primes[j] == -1) primes[j] = i;",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "Sieve of Eratosthenes with smallest prime factor for each number"
    },
    "right_check": {
        "prefix": "right_angle_check",
        "body": [
            "bool right_check(int *x, int *y) {",
            "    for (int i = 0; i < 3; i++) {",
            "        int a = (y[(i + 1) % 3] - y[i % 3]) * (y[(i + 2) % 3] - y[(i + 1) % 3]);",
            "        int b = (x[(i + 1) % 3] - x[i % 3]) * (x[(i + 2) % 3] - x[(i + 1) % 3]);",
            "        if (a + b == 0) return true;",
            "    }",
            "    return false;",
            "}"
        ],
        "description": "Checks if three points form a right angle based on their coordinates."
    },
    "ModInt Template": {
        "prefix": "mint",
        "body": [
            "template<int64_t MOD_ = mod1> struct modint_t {",
            "    static constexpr int64_t MOD = MOD_;",
            "    static_assert(MOD_ > 0);",
            "    int64_t val;",
            "    modint_t(int64_t _val = 0) : val(_val % MOD) {",
            "        if(val < 0) val += MOD;",
            "    }",
            "    explicit operator int64_t() const {",
            "        return val;",
            "    }",
            "    int64_t get_mod(){",
            "        return MOD;",
            "    }",
            "    friend std::ostream& operator<<(std::ostream& out, const modint_t& p){",
            "        out << int64_t(p);",
            "        return out;",
            "    }",
            "    friend std::istream& operator>>(std::istream& in, modint_t& p){",
            "        int64_t v;",
            "        in >> v;",
            "        p = modint_t(v);",
            "        return in;",
            "    }",
            "    modint_t operator+ (modint_t other) const {",
            "        return modint_t(val + other.val);",
            "    }",
            "    void operator+= (modint_t other){",
            "        val += other.val;",
            "        val %= MOD;",
            "    }",
            "    modint_t operator- () const {",
            "        return modint_t(MOD - val);",
            "    }",
            "    modint_t operator- (modint_t other) const {",
            "        return modint_t(val + MOD - other.val);",
            "    }",
            "    void operator-= (modint_t other) {",
            "        val += MOD - other.val;",
            "        val %= MOD;",
            "    }",
            "    modint_t operator* (modint_t other) const {",
            "        return modint_t(val * other.val);",
            "    }",
            "    void operator*= (modint_t other) {",
            "        val *= other.val;",
            "        val %= MOD;",
            "    }",
            "    bool operator== (modint_t other) const {",
            "        return val == other.val;",
            "    }",
            "    bool operator!= (modint_t other) const {",
            "        return val != other.val;",
            "    }",
            "    modint_t& operator++() {",
            "        val = (val + 1) % MOD;",
            "        return *this;",
            "    }    ",
            "    modint_t operator++(int) {",
            "        modint_t temp = *this;",
            "        ++(*this);",
            "        return temp;",
            "    }  ",
            "    modint_t& operator--() {",
            "        val = (val - 1 + MOD) % MOD;",
            "        return *this;  ",
            "    }  ",
            "    modint_t operator--(int) {",
            "        modint_t temp = *this;",
            "        --(*this);",
            "        return temp;",
            "    } ",
            "};",
            "template<int64_t MOD_ = mod1>",
            "modint_t<MOD_> pow(modint_t<MOD_> a, int64_t p) {",
            "    assert(p >= 0);",
            "    return p == 0 ? modint_t<MOD_>(1) : pow(a * a, p / 2) * modint_t<MOD_>(p & 1 ? a : 1);",
            "}",
            "template<int64_t MOD_ = mod1>",
            "modint_t<MOD_> inverse (modint_t<MOD_> a) {",
            "    assert(int64_t(a) != 0);",
            "    return pow(a, MOD_ - 2);",
            "}",
            "template<int64_t MOD_ = mod1>",
            "modint_t<MOD_> operator/(modint_t<MOD_> a, modint_t<MOD_> b) {",
            "    return a * inverse(b);",
            "}",
            "template<int64_t MOD_ = mod1>",
            "modint_t<MOD_> operator/(modint_t<MOD_> a, int64_t b) {",
            "    return a / modint_t<MOD_>(b);",
            "}",
            "template<int64_t MOD_ = mod1>",
            "modint_t<MOD_>& operator/=(modint_t<MOD_> &a, modint_t<MOD_> b) {",
            "    return a = a / b;",
            "}",
            "template<int64_t MOD_ = mod1>",
            "modint_t<MOD_> operator/=(modint_t<MOD_> &a, int64_t b) {",
            "    return a = a / modint_t<MOD_>(b);",
            "} ",
            "using mint64_t = modint_t<>;",
            "using mll = mint64_t;"
        ],
        "description": "ModInt Template for Competitive Programming"
    },
    "dfs": {
        "prefix": "dfs",
        "body": [
            "vector<vector<lli>> arr(MAXN);",
            "vector<bool> vis(MAXN);",
            "void dfs(lli v) {",
            "    vis[v] = 1;",
            "    for (auto child : arr[v]) {",
            "        if (vis[child] == 0) dfs(child);",
            "    }",
            "}"
        ],
        "description": "Depth First Search (DFS)"
    },
    "bfs": {
        "prefix": "bfs",
        "body": [
            "vector<vector<lli>> arr(MAXN);",
            "vector<bool> vis(MAXN);",
            "void bfs(lli src) {",
            "    queue<lli> q;",
            "    q.push(src);",
            "    vis[src] = 1;",
            "    while (!q.empty()) {",
            "        lli v = q.front();",
            "        q.pop();",
            "        for (auto child : arr[v]) {",
            "            if (vis[child] == 0) {",
            "                vis[child] = 1;",
            "                q.push(child);",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "Breadth First Search (BFS)"
    },
    "connected_components": {
        "prefix": "cc",
        "body": [
            "lli countConnectedComponents(lli n, vector<vector<lli>> &arr) {",
            "    vector<bool> vis(n, 0);",
            "    lli cc = 0;",
            "    for (lli i = 0; i < n; i++) {",
            "        if (vis[i] == 0) {",
            "            cc++;",
            "            dfs(i, arr, vis);",
            "        }",
            "    }",
            "    return cc;",
            "}"
        ],
        "description": "Count Connected Components using DFS"
    },
    "dijkstra": {
        "prefix": "dijkstra",
        "body": [
            "vector<lli> dijkstra(lli start, vector<vector<pair<lli, lli>>> &adj, lli n) {",
            "    vector<lli> dist(n + 1, INT_MAX);",
            "    priority_queue<pair<lli, lli>, vector<pair<lli, lli>>, greater<pair<lli, lli>>> pq;",
            "    dist[start] = 0;",
            "    pq.push({0, start});",
            "    while (!pq.empty()) {",
            "        auto [d, u] = pq.top();",
            "        pq.pop();",
            "        if (d > dist[u]) continue;",
            "        for (auto &[v, w] : adj[u]) {",
            "            if (dist[u] + w < dist[v]) {",
            "                dist[v] = dist[u] + w;",
            "                pq.push({dist[v], v});",
            "            }",
            "        }",
            "    }",
            "    return dist;",
            "}"
        ],
        "description": "Dijkstra's algorithm to find the shortest path from a source node."
    },
    "kruskal": {
        "prefix": "kruskal",
        "body": [
            "struct Edge {",
            "    lli u, v, w;",
            "    bool operator<(const Edge &other) const {",
            "        return w < other.w;",
            "    }",
            "};",
            "vector<Edge> edges;",
            "vector<lli> parent, rank;",
            "",
            "lli find(lli x) {",
            "    return parent[x] = (parent[x] == x ? x : find(parent[x]));",
            "}",
            "bool unite(lli x, lli y) {",
            "    x = find(x);",
            "    y = find(y);",
            "    if (x == y) return false;",
            "    if (rank[x] < rank[y]) swap(x, y);",
            "    parent[y] = x;",
            "    if (rank[x] == rank[y]) rank[x]++;",
            "    return true;",
            "}",
            "lli kruskal(lli n) {",
            "    sort(edges.begin(), edges.end());",
            "    parent.resize(n + 1);",
            "    rank.resize(n + 1, 0);",
            "    iota(parent.begin(), parent.end(), 0);",
            "    lli mst_cost = 0;",
            "    for (auto &e : edges) {",
            "        if (unite(e.u, e.v)) {",
            "            mst_cost += e.w;",
            "        }",
            "    }",
            "    return mst_cost;",
            "}"
        ],
        "description": "Kruskal's algorithm to find the Minimum Spanning Tree (MST)."
    },
    "bellman_ford": {
        "prefix": "bellman_ford",
        "body": [
            "vector<lli> bellman_ford(lli start, vector<vector<lli>> &edges, lli n) {",
            "    vector<lli> dist(n + 1, INT_MAX);",
            "    dist[start] = 0;",
            "    for (lli i = 1; i <= n - 1; i++) {",
            "        for (auto &e : edges) {",
            "            lli u = e[0], v = e[1], w = e[2];",
            "            if (dist[u] != INT_MAX && dist[u] + w < dist[v]) {",
            "                dist[v] = dist[u] + w;",
            "            }",
            "        }",
            "    }",
            "    return dist;",
            "}"
        ],
        "description": "Bellman-Ford algorithm to find shortest paths in a graph with negative weights."
    },
    "floyd_warshall": {
        "prefix": "floyd_warshall",
        "body": [
            "void floyd_warshall(vector<vector<lli>> &dist, lli n) {",
            "    for (lli k = 0; k < n; k++) {",
            "        for (lli i = 0; i < n; i++) {",
            "            for (lli j = 0; j < n; j++) {",
            "                if (dist[i][k] != INT_MAX && dist[k][j] != INT_MAX) {",
            "                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);",
            "                }",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "Floyd-Warshall algorithm to find shortest paths between all pairs of nodes."
    },
    "toposort": {
        "prefix": "toposort",
        "body": [
            "void topological_sort(lli node, vector<vector<lli>> &adj, vector<lli> &visited, stack<lli> &st) {",
            "    visited[node] = 1;",
            "    for (auto &neighbor : adj[node]) {",
            "        if (!visited[neighbor]) {",
            "            topological_sort(neighbor, adj, visited, st);",
            "        }",
            "    }",
            "    st.push(node);",
            "}",
            "vector<lli> get_toposort(lli n, vector<vector<lli>> &adj) {",
            "    vector<lli> visited(n, 0);",
            "    stack<lli> st;",
            "    for (lli i = 0; i < n; i++) {",
            "        if (!visited[i]) {",
            "            topological_sort(i, adj, visited, st);",
            "        }",
            "    }",
            "    vector<lli> order;",
            "    while (!st.empty()) {",
            "        order.push_back(st.top());",
            "        st.pop();",
            "    }",
            "    return order;",
            "}"
        ],
        "description": "Topological Sort using DFS."
    },
    "Prime Check using sqrt(n)": {
        "prefix": "prime_sqrt_n",
        "body": [
            "bool isPrime(lli n) {",
            "    if (n <= 1) return false; // 0 and 1 are not prime numbers",
            "    if (n <= 3) return true;  // 2 and 3 are prime numbers",
            "",
            "    // Eliminate multiples of 2 and 3",
            "    if (n % 2 == 0 || n % 3 == 0) return false;",
            "",
            "    // Check divisibility from 5 to sqrt(n)",
            "    for (lli i = 5; i * i <= n; i += 6) {",
            "        if (n % i == 0 || n % (i + 2) == 0) return false;",
            "    }",
            "",
            "    return true;",
            "}",
            ""
        ],
        "description": "Check if a number is prime using the sqrt(n) optimization."
    },
    "Compute XOR Function": {
        "prefix": "xorfunc",
        "body": [
            "ull getXOR(ull n)",
            "{",
            "    vector<ull> _p = {n, 1, n + 1, 0};",
            "    return _p[n % 4];",
            "}"
        ],
        "description": "Function to compute XOR of numbers from 1 to n"
    },
    "prime_factorization": {
        "prefix": "prime_factors",
        "body": [
            "map<lli, lli> prime_factorize(lli n) {",
            "    map<lli, lli> factors;",
            "    for (lli i = 2; i * i <= n; i++) {",
            "        while (n % i == 0) {",
            "            factors[i]++;",
            "            n /= i;",
            "        }",
            "    }",
            "    if (n > 1) factors[n]++;",
            "    return factors;",
            "}"
        ],
        "description": "Prime factorization of a number"
    },
    "combinatorics": {
        "prefix": "combinatorics",
        "body": [
            "vector<lli> factorial(lli n=MAXN, lli mod=mod) {",
            "    vector<lli> fact(n + 1, 1);",
            "    for (lli i = 2; i <= n; i++) {",
            "        fact[i] = (1LL * fact[i - 1] * i) % mod;",
            "    }",
            "    return fact;",
            "}",
            "lli nCr(lli n, lli r, const vector<lli>& fact, lli mod=mod) {",
            "    if (r > n) return 0;",
            "    lli numerator = fact[n];",
            "    lli denominator = (1LL * fact[r] * fact[n - r]) % mod;",
            "    return (1LL * numerator * mpow(denominator, mod - 2, mod)) % mod;",
            "}",
            "lli nPr(lli n, lli r, const vector<lli>& fact, lli mod=mod) {",
            "    if (r > n) return 0;",
            "    lli numerator = fact[n];",
            "    lli denominator = (1LL * fact[n - r]) % mod;",
            "    return (1LL * numerator * mpow(denominator, mod - 2, mod)) % mod;",
            "}"
        ],
        "description": "Combinatorics with factorial and nCr calculation"
    },
    "mod_inverse": {
        "prefix": "mod_inv",
        "body": [
            "lli mod_inverse(lli a, lli m) {",
            "    a %= m;",
            "    for (lli x = 1; x < m; x++) {",
            "        if ((a * x) % m == 1) return x;",
            "    }",
            "    return -1;",
            "}"
        ],
        "description": "Calculate modular inverse of a number"
    },
    "Modular Combination Function (lazy static with nPr)": {
        "prefix": "combmod",
        "body": [
            "ll comb(ll N_, ll C_) {",
            "    const lli NUM_ = 400001;",
            "    static ll fact[NUM_ + 1], factr[NUM_ + 1], inv[NUM_ + 1];",
            "    if (fact[0] == 0) {",
            "        inv[1] = fact[0] = factr[0] = 1;",
            "        for (lli i = 2; i <= NUM_; ++i)",
            "            inv[i] = inv[mod % i] * (mod - mod / i) % mod;",
            "        for (lli i = 1; i <= NUM_; ++i) {",
            "            fact[i] = fact[i - 1] * i % mod;",
            "            factr[i] = factr[i - 1] * inv[i] % mod;",
            "        }",
            "    }",
            "    if (C_ < 0 || C_ > N_) return 0;",
            "    return factr[C_] * fact[N_] % mod * factr[N_ - C_] % mod;",
            "    // return fact[N_] * factr[N_ - C_] % mod; // Use this for nPr (N_P_C mod mod)",
            "}"
        ],
        "description": "Efficient modular combination function using 'mod' with lazy static precomputation and nPr option"
    },
    "prefix_sum": {
        "prefix": "prefix_sum",
        "body": [
            "vector<lli> prefix_sum(const vector<lli>& arr) {",
            "    vector<lli> prefix(arr.size() + 1, 0);",
            "    for (lli i = 1; i <= arr.size(); i++) {",
            "        prefix[i] = prefix[i - 1] + arr[i - 1];",
            "    }",
            "    return prefix;",
            "}"
        ],
        "description": "Calculate prefix sums of an array"
    },
    "difference_array": {
        "prefix": "diff_array",
        "body": [
            "vector<lli> difference_array(const vector<lli>& arr) {",
            "    vector<lli> diff(arr.size() + 1, 0);",
            "    for (lli i = 1; i < arr.size(); i++) {",
            "        diff[i] = arr[i] - arr[i - 1];",
            "    }",
            "    return diff;",
            "}"
        ],
        "description": "Calculate difference array for range updates"
    },
    "count_divisors": {
        "prefix": "divisor_count",
        "body": [
            "lli count_divisors(lli n) {",
            "    map<lli, lli> factors = prime_factorize(n);",
            "    lli count = 1;",
            "    for (auto &[prime, power] : factors) {",
            "        count *= (power + 1);",
            "    }",
            "    return count;",
            "}"
        ],
        "description": "Count the divisors of a number"
    },
    "crt": {
        "prefix": "chinese_remainder",
        "body": [
            "lli crt(const vector<lli>& rem, const vector<lli>& mod) {",
            "    lli prod = 1, result = 0;",
            "    for (lli x : mod) prod *= x;",
            "    for (lli i = 0; i < rem.size(); i++) {",
            "        lli pp = prod / mod[i];",
            "        result += rem[i] * mod_inverse(pp, mod[i]) * pp;",
            "        result %= prod;",
            "    }",
            "    return (result + prod) % prod;",
            "}"
        ],
        "description": "Chinese Remainder Theorem to solve modular equations"
    },
    "fibonacci_matrix": {
        "prefix": "fibonacci_matrix",
        "body": [
            "void multiply(vector<vector<lli>> &a, vector<vector<lli>> &b, lli mod) {",
            "    lli x = a[0][0] * b[0][0] + a[0][1] * b[1][0];",
            "    lli y = a[0][0] * b[0][1] + a[0][1] * b[1][1];",
            "    lli z = a[1][0] * b[0][0] + a[1][1] * b[1][0];",
            "    lli w = a[1][0] * b[0][1] + a[1][1] * b[1][1];",
            "    a[0][0] = x % mod;",
            "    a[0][1] = y % mod;",
            "    a[1][0] = z % mod;",
            "    a[1][1] = w % mod;",
            "}",
            "void matrix_exponentiation(vector<vector<lli>> &a, lli n, lli mod) {",
            "    vector<vector<lli>> res = {{1, 0}, {0, 1}};",
            "    while (n > 0) {",
            "        if (n % 2 == 1) multiply(res, a, mod);",
            "        multiply(a, a, mod);",
            "        n /= 2;",
            "    }",
            "    a = res;",
            "}"
        ],
        "description": "Matrix Exponentiation to compute Fibonacci numbers efficiently"
    },
    "Binary Search Function": {
        "prefix": "binary_search_fun",
        "body": [
            "lli l = 0, h = (lli)2e18;",
            "lli ans = h;",
            "",
            "while (l <= h) {",
            "    lli mid = (l + h) >> 1; // Equivalent to (l + h) / 2",
            "    if (f(mid)) {",
            "        ans = mid;",
            "        h = mid - 1;",
            "    } else {",
            "        l = mid + 1;",
            "    }",
            "}",
            "",
            "// Replace f(mid) with your condition function"
        ],
        "description": "Generic binary search implementation with a condition function."
    },
    "geometry_cross_product": {
        "prefix": "dist",
        "body": [
            "lli dist(lli x1, lli y1, lli x2, lli y2) {",
            "    return x1 * y2 - y1 * x2;",
            "}"
        ],
        "description": "Compute the cross product of two vectors"
    },
    "2d_dfs": {
        "prefix": "dfs_grid",
        "body": [
            "lli n, m;",
            "vector<vector<char>> arr(1006, vector<char>(1006));",
            "vector<vector<bool>> vis(1006, vector<bool>(1006));",
            "bool isValid(lli x, lli y)",
            "{",
            "    return (x >= 0 && x < n && y >= 0 && y < m && !vis[x][y] && arr[x][y] != '#');",
            "}",
            "",
            "void dfs(lli x, lli y)",
            "{",
            "    vis[x][y] = true;",
            "",
            "    for (lli i = 0; i < 4; i++)",
            "    {",
            "        lli nx = x + dx[i], ny = y + dy[i];",
            "        if (isValid(nx, ny))",
            "        {",
            "            dfs(nx, ny);",
            "        }",
            "    }",
            "}"
        ],
        "description": "2D DFS for traversing a grid"
    },
    "DFS Bipartite Check": {
        "prefix": "dfs_bipartite",
        "body": [
            "vector<vector<lli>> arr(MAXN);",
            "vector<bool> vis(MAXN);",
            "set<lli> s[2];",
            "vll col(MAXN);",
            "lli flag = 1;",
            "",
            "void dfs(lli v, lli c = 0) {",
            "    vis[v] = 1;",
            "    col[v] = c;",
            "    if (arr[v].size() >= 1) s[c].insert(v);",
            "    for (auto child : arr[v]) {",
            "        if (vis[child] == 0) dfs(child, c ^ 1);",
            "        flag &= !(vis[child] && col[child] == c);",
            "    }",
            "}",
            ""
        ],
        "description": "DFS function to check if a graph is bipartite."
    },
    "2d_bfs": {
        "prefix": "bfs_grid",
        "body": [
            "lli n, m;",
            "vector<vector<char>> arr(1006, vector<char>(1006));",
            "vector<vector<bool>> vis(1006, vector<bool>(1006));",
            "bool isValid(lli x, lli y)",
            "{",
            "    return (x >= 0 && x < n && y >= 0 && y < m && !vis[x][y] && arr[x][y] != '#');",
            "}",
            "",
            "void bfs(lli x, lli y)",
            "{",
            "    queue<pair<lli, lli>> q;",
            "    q.push({x, y});",
            "    vis[x][y] = true;",
            "",
            "    while (!q.empty())",
            "    {",
            "        auto [cx, cy] = q.front();",
            "        q.pop();",
            "",
            "        for (lli i = 0; i < 4; i++)",
            "        {",
            "            lli nx = cx + dx[i], ny = cy + dy[i];",
            "            if (isValid(nx, ny))",
            "            {",
            "                vis[nx][ny] = true;",
            "                q.push({nx, ny});",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "2D BFS for traversing a grid"
    },
    "count_connected_components": {
        "prefix": "count_cc2",
        "body": [
            "lli countConnectedComponents(vector<vector<char>> &arr, lli n, lli m) {",
            "    vector<vector<bool>> vis(n, vector<bool>(m, false));",
            "    lli components = 0;",
            "",
            "    for (lli i = 0; i < n; i++) {",
            "        for (lli j = 0; j < m; j++) {",
            "            if (!vis[i][j] && arr[i][j] == '.') {",
            "                components++;",
            "                // Use either DFS or BFS:",
            "                dfs(i, j, n, m, arr, vis);",
            "                // bfs(i, j, n, m, arr, vis);",
            "            }",
            "        }",
            "    }",
            "    return components;",
            "}"
        ],
        "description": "Count connected components in a 2D grid using DFS or BFS"
    },
    "Subset Generation Loop": {
        "prefix": "mask",
        "body": [
            "for (lli i = 0; i < (1 << ${1:n}); i++) {",
            "    vector<lli> subset;",
            "    for (lli j = 0; j < ${1:n}; j++) {",
            "        if (i & (1 << j)) {",
            "            subset.push_back(j);",
            "        }",
            "    }",
            "}"
        ],
        "description": "Generate all subsets of a set using bitmasking"
    },
    "DSU Class": {
        "prefix": "dsu",
        "body": [
            "class DSU",
            "{",
            "    vll rank, parent;",
            "",
            "public:",
            "    DSU(lli n)",
            "    {",
            "        rank.resize(n + 1, 0);",
            "        parent.resize(n + 1);",
            "        for (lli i = 0; i <= n; ++i)",
            "        {",
            "            parent[i] = i;",
            "        }",
            "    }",
            "",
            "    lli find(lli node)",
            "    {",
            "        if (node == parent[node])",
            "        {",
            "            return node;",
            "        }",
            "        return parent[node] = find(parent[node]); // Path compression",
            "    }",
            "",
            "    void unionSets(lli u, lli v)",
            "    {",
            "        lli rootU = find(u);",
            "        lli rootV = find(v);",
            "",
            "        if (rootU == rootV)",
            "        {",
            "            return; // Both elements are already in the same set",
            "        }",
            "",
            "        // Union by rank",
            "        if (rank[rootU] < rank[rootV])",
            "        {",
            "            parent[rootU] = rootV;",
            "        }",
            "        else if (rank[rootV] < rank[rootU])",
            "        {",
            "            parent[rootV] = rootU;",
            "        }",
            "        else",
            "        {",
            "            parent[rootV] = rootU;",
            "            rank[rootU]++;",
            "        }",
            "    }",
            "};"
        ],
        "description": "Insert a Disjoint Set Union (DSU) class with path compression and union by rank"
    },
    "Euler Totient Sieve": {
        "prefix": "etf_sieve",
        "body": [
            "",
            "// Function to compute Euler Totient Function for all numbers up to n using Sieve",
            "std::vector<lli> eulerTotientSieve(lli n=MAXN) {",
            "    std::vector<lli> phi(n + 1); // Vector to store Euler Totient values",
            "",
            "    // Initialize the phi array",
            "    for (lli i = 0; i <= n; i++) {",
            "        phi[i] = i; // Initially, phi[i] = i",
            "    }",
            "",
            "    // Apply Sieve-like approach to compute phi",
            "    for (lli p = 2; p <= n; p++) {",
            "        // If phi[p] == p, then p is a prime number",
            "        if (phi[p] == p) {",
            "            phi[p] = p - 1; // For a prime p, phi(p) = p - 1",
            "",
            "            // Update all multiples of p",
            "            for (lli multiple = 2 * p; multiple <= n; multiple += p) {",
            "                phi[multiple] = (phi[multiple] / p) * (p - 1);",
            "            }",
            "        }",
            "    }",
            "",
            "    return phi;",
            "}"
        ],
        "description": "Computes the Euler Totient Function (φ) for all numbers from 1 to n using a Sieve-like approach."
    },
    "Euler Totient Sqrt(n)": {
        "prefix": "etf_sqrtn",
        "body": [
            "lli phi(lli n) {",
            "    lli result = n;",
            "    for (lli p = 2; p * p <= n; p++) {",
            "        if (n % p == 0) {",
            "            while (n % p == 0) n /= p;",
            "            result -= result / p;",
            "        }",
            "    }",
            "",
            "    if (n > 1) {",
            "        result -= result / n;",
            "    }",
            "",
            "    return result;",
            "}",
            ""
        ],
        "description": "Computes the Euler Totient Function (φ) for a single number n using the square root decomposition approach."
    },
    "LCIS Function": {
        "prefix": "lcis",
        "body": [
            "lli lcis(vll &a) {//Longest Consecutive Increasing Subsequence",
            "    lli n = a.size();",
            "    unordered_map<lli, lli> mp;",
            "    lli dp[n];",
            "    memset(dp, 0, sizeof(dp));",
            "    lli mx = INT32_MIN;",
            "    for (lli i = 0; i < n; i++) {",
            "        if (mp.count(a[i] - 1)) {",
            "            lli last = mp[a[i] - 1] - 1;",
            "            dp[i] = 1 + dp[last];",
            "        } else {",
            "            dp[i] = 1;",
            "        }",
            "        mp[a[i]] = i + 1;",
            "        mx = max(mx, dp[i]);",
            "    }",
            "    return mx;",
            "}"
        ],
        "description": "Returns the length of the Longest Consecutive Increasing Subsequence"
    },
    "LIS Function": {
        "prefix": "lis",
        "body": [
            "lli lis(vll &arr) {//longrest increasing subsequence",
            "    lli n = arr.size();",
            "    vll ans;",
            "    ans.push_back(arr[0]);",
            "",
            "    for (int i = 1; i < n; i++) {",
            "        if (arr[i] > ans.back())",
            "            ans.push_back(arr[i]);",
            "        else {",
            "            lli low = lower_bound(all(ans), arr[i]) - ans.begin();",
            "            ans[low] = arr[i];",
            "        }",
            "    }",
            "    return ans.size();",
            "}"
        ],
        "description": "Returns the length of the Longest Increasing Subsequence using binary search"
    },
    "LCS template function": {
        "prefix": "lcs",
        "body": [
            "template <typename T>  //Longest Common Subsequenc",
            "auto lcs(const T& s1, const T& s2) -> decltype(s1.size()) {",
            "    using size_type = decltype(s1.size());",
            "    size_type n = s1.size();",
            "    size_type m = s2.size();",
            "",
            "    std::vector<size_type> prev(m + 1, 0), cur(m + 1, 0);",
            "",
            "    for (size_type ind1 = 1; ind1 <= n; ++ind1) {",
            "        for (size_type ind2 = 1; ind2 <= m; ++ind2) {",
            "            if (s1[ind1 - 1] == s2[ind2 - 1]) {",
            "                cur[ind2] = 1 + prev[ind2 - 1];",
            "            } else {",
            "                cur[ind2] = std::max(prev[ind2], cur[ind2 - 1]);",
            "            }",
            "        }",
            "        prev = cur;",
            "    }",
            "    return prev[m];",
            "}"
        ],
        "description": "Template for LCS function supporting generic container types"
    }
}